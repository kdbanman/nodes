import processing.core.*; 
import processing.data.*; 
import processing.event.*; 
import processing.opengl.*; 

import controlP5.*; 
import peasy.*; 
import com.hp.hpl.jena.query.*; 
import com.hp.hpl.jena.rdf.model.*; 
import virtuoso.jena.driver.*; 
import java.awt.Frame; 
import java.awt.BorderLayout; 
import java.util.ArrayList; 
import java.util.HashMap; 
import java.util.ArrayList; 
import com.hp.hpl.jena.rdf.model.*; 

import com.hp.hpl.jena.sparql.expr.aggregate.*; 
import org.apache.http.protocol.*; 
import org.apache.xerces.impl.dv.dtd.*; 
import org.apache.http.util.*; 
import org.apache.jena.riot.adapters.*; 
import com.hp.hpl.jena.sparql.engine.main.*; 
import org.apache.xerces.dom.events.*; 
import org.apache.jena.riot.lang.*; 
import org.apache.xerces.impl.dv.xs.*; 
import org.apache.log4j.config.*; 
import javax.xml.validation.*; 
import org.apache.jena.atlas.data.*; 
import org.apache.xerces.impl.dv.util.*; 
import javax.xml.transform.dom.*; 
import org.apache.log4j.lf5.viewer.categoryexplorer.*; 
import com.hp.hpl.jena.tdb.setup.*; 
import com.hp.hpl.jena.sparql.algebra.optimize.*; 
import org.apache.xerces.impl.dtd.models.*; 
import com.hp.hpl.jena.sparql.function.library.*; 
import org.apache.log4j.helpers.*; 
import org.xml.sax.ext.*; 
import com.hp.hpl.jena.tdb.index.bplustree.*; 
import org.apache.xerces.impl.io.*; 
import org.apache.jena.atlas.*; 
import javax.xml.stream.*; 
import arq.cmdline.*; 
import com.hp.hpl.jena.sparql.engine.main.iterator.*; 
import com.hp.hpl.jena.sparql.sse.lang.parser.*; 
import com.hp.hpl.jena.sparql.path.eval.*; 
import org.apache.log4j.lf5.viewer.configure.*; 
import org.w3c.dom.events.*; 
import com.hp.hpl.jena.rdf.arp.lang.*; 
import org.apache.log4j.or.sax.*; 
import com.hp.hpl.jena.*; 
import org.openjena.riot.*; 
import com.hp.hpl.jena.mem.*; 
import peasy.test.*; 
import com.hp.hpl.jena.sparql.util.graph.*; 
import com.hp.hpl.jena.assembler.*; 
import org.apache.xmlcommons.*; 
import org.apache.http.auth.*; 
import com.hp.hpl.jena.sparql.sse.builders.*; 
import com.hp.hpl.jena.sparql.engine.binding.*; 
import org.apache.http.client.utils.*; 
import com.hp.hpl.jena.sparql.function.*; 
import org.slf4j.impl.*; 
import javax.xml.stream.util.*; 
import com.hp.hpl.jena.rdf.listeners.*; 
import com.hp.hpl.jena.shared.wg.*; 
import javax.xml.datatype.*; 
import org.apache.jena.riot.process.inf.*; 
import com.hp.hpl.jena.sparql.pfunction.*; 
import com.hp.hpl.jena.shared.impl.*; 
import com.hp.hpl.jena.sparql.procedure.*; 
import org.apache.html.dom.*; 
import com.hp.hpl.jena.sparql.expr.nodevalue.*; 
import org.apache.log4j.lf5.*; 
import org.apache.commons.codec.language.bm.*; 
import com.hp.hpl.jena.sparql.algebra.op.*; 
import org.apache.jena.riot.checker.*; 
import com.hp.hpl.jena.sparql.path.*; 
import peasy.org.apache.commons.math.geometry.*; 
import org.apache.http.conn.*; 
import com.hp.hpl.jena.tdb.base.page.*; 
import org.apache.jena.atlas.lib.cache.*; 
import org.apache.xerces.jaxp.*; 
import org.apache.http.impl.entity.*; 
import javax.xml.transform.*; 
import org.apache.xerces.impl.xpath.*; 
import com.hp.hpl.jena.tdb.store.bulkloader2.*; 
import org.apache.jena.riot.out.*; 
import com.hp.hpl.jena.rdf.model.impl.*; 
import org.w3c.dom.html.*; 
import com.hp.hpl.jena.sparql.engine.optimizer.*; 
import com.hp.hpl.jena.util.iterator.*; 
import com.hp.hpl.jena.util.*; 
import com.hp.hpl.jena.sparql.*; 
import org.apache.http.pool.*; 
import com.hp.hpl.jena.reasoner.rulesys.builtins.*; 
import org.w3c.dom.views.*; 
import tdb.cmdline.*; 
import org.apache.log4j.or.*; 
import org.apache.jena.atlas.io.*; 
import com.hp.hpl.jena.sparql.mgt.*; 
import org.apache.jena.atlas.iterator.*; 
import com.hp.hpl.jena.sparql.graph.*; 
import org.apache.log4j.varia.*; 
import org.apache.http.conn.ssl.*; 
import org.apache.xerces.impl.dv.*; 
import org.apache.log4j.*; 
import com.hp.hpl.jena.sparql.sse.*; 
import com.hp.hpl.jena.reasoner.transitiveReasoner.*; 
import org.apache.xerces.jaxp.datatype.*; 
import org.apache.http.client.entity.*; 
import org.apache.log4j.nt.*; 
import com.hp.hpl.jena.shared.*; 
import com.hp.hpl.jena.sparql.modify.*; 
import com.hp.hpl.jena.reasoner.rulesys.impl.*; 
import org.apache.http.impl.cookie.*; 
import com.hp.hpl.jena.n3.*; 
import org.apache.http.params.*; 
import org.apache.log4j.jmx.*; 
import com.hp.hpl.jena.xmloutput.*; 
import com.hp.hpl.jena.n3.turtle.*; 
import org.apache.xerces.impl.xs.traversers.*; 
import org.apache.http.conn.util.*; 
import com.hp.hpl.jena.tdb.index.factories.*; 
import org.apache.http.impl.auth.*; 
import org.apache.jena.riot.*; 
import com.hp.hpl.jena.sparql.algebra.table.*; 
import com.hp.hpl.jena.tdb.migrate.*; 
import virtuoso.javax.*; 
import com.hp.hpl.jena.shared.uuid.*; 
import org.apache.xerces.impl.*; 
import com.hp.hpl.jena.sparql.lang.arq.*; 
import org.apache.http.cookie.*; 
import com.hp.hpl.jena.tdb.sys.*; 
import org.apache.jena.atlas.web.*; 
import org.apache.jena.riot.tokens.*; 
import com.hp.hpl.jena.tdb.modify.*; 
import org.w3c.dom.xpath.*; 
import com.hp.hpl.jena.query.*; 
import org.apache.commons.codec.binary.*; 
import org.apache.http.io.*; 
import org.apache.http.message.*; 
import com.hp.hpl.jena.tdb.solver.stats.*; 
import peasy.org.apache.commons.math.*; 
import controlP5.*; 
import com.hp.hpl.jena.tdb.base.record.*; 
import org.apache.xerces.xinclude.*; 
import org.apache.xerces.impl.xs.opti.*; 
import com.hp.hpl.jena.sparql.vocabulary.*; 
import org.apache.log4j.pattern.*; 
import org.apache.jena.web.*; 
import com.hp.hpl.jena.tdb.base.file.*; 
import org.xml.sax.helpers.*; 
import org.apache.jena.iri.*; 
import org.apache.http.annotation.*; 
import com.hp.hpl.jena.tdb.*; 
import com.hp.hpl.jena.datatypes.*; 
import org.apache.http.impl.conn.*; 
import com.hp.hpl.jena.sparql.function.user.*; 
import org.apache.xerces.xpointer.*; 
import org.w3c.dom.bootstrap.*; 
import org.apache.xerces.stax.events.*; 
import com.hp.hpl.jena.tdb.index.ext.*; 
import com.hp.hpl.jena.rdf.arp.*; 
import com.hp.hpl.jena.sparql.engine.optimizer.reorder.*; 
import com.hp.hpl.jena.sparql.sse.lang.*; 
import org.apache.http.impl.pool.*; 
import com.hp.hpl.jena.sparql.engine.iterator.*; 
import org.apache.xerces.jaxp.validation.*; 
import com.hp.hpl.jena.sparql.lib.*; 
import com.hp.hpl.jena.tdb.base.block.*; 
import org.apache.xerces.impl.xs.*; 
import org.apache.jena.atlas.logging.java.*; 
import tdb.*; 
import javax.xml.transform.stax.*; 
import com.hp.hpl.jena.datatypes.xsd.impl.*; 
import org.slf4j.spi.*; 
import org.apache.xerces.xni.parser.*; 
import org.apache.xerces.impl.xpath.regex.*; 
import com.hp.hpl.jena.sparql.sse.writers.*; 
import org.apache.xerces.impl.xs.models.*; 
import com.hp.hpl.jena.reasoner.*; 
import org.apache.log4j.lf5.util.*; 
import com.hp.hpl.jena.rdf.arp.impl.*; 
import org.apache.jena.atlas.json.io.*; 
import org.w3c.dom.ranges.*; 
import org.apache.log4j.chainsaw.*; 
import com.hp.hpl.jena.vocabulary.*; 
import org.apache.commons.codec.*; 
import org.apache.xerces.impl.xs.identity.*; 
import virtuoso.jena.driver.*; 
import org.xml.sax.*; 
import com.hp.hpl.jena.sparql.procedure.library.*; 
import org.apache.http.conn.routing.*; 
import com.hp.hpl.jena.tdb.solver.*; 
import com.hp.hpl.jena.sparql.modify.request.*; 
import jena.cmdline.*; 
import javax.xml.parsers.*; 
import com.hp.hpl.jena.tdb.base.*; 
import riotcmd.*; 
import org.apache.http.client.methods.*; 
import org.apache.jena.atlas.test.*; 
import org.apache.http.impl.*; 
import com.hp.hpl.jena.rdf.model.*; 
import openlink.util.*; 
import org.slf4j.*; 
import com.hp.hpl.jena.tdb.mgt.*; 
import com.hp.hpl.jena.rdf.arp.states.*; 
import org.apache.commons.logging.*; 
import org.apache.http.client.params.*; 
import com.hp.hpl.jena.update.*; 
import org.apache.jena.atlas.json.*; 
import org.apache.http.auth.params.*; 
import org.apache.log4j.net.*; 
import org.apache.wml.*; 
import com.hp.hpl.jena.datatypes.xsd.*; 
import com.hp.hpl.jena.sparql.util.*; 
import org.apache.commons.logging.impl.*; 
import org.apache.xerces.impl.msg.*; 
import org.apache.http.cookie.params.*; 
import com.hp.hpl.jena.sparql.engine.index.*; 
import com.hp.hpl.jena.util.cache.*; 
import org.apache.jena.riot.system.*; 
import com.hp.hpl.jena.assembler.exceptions.*; 
import org.apache.wml.dom.*; 
import org.w3c.dom.css.*; 
import org.apache.xerces.dom3.as.*; 
import com.hp.hpl.jena.sparql.engine.*; 
import org.apache.jena.riot.process.normalize.*; 
import com.hp.hpl.jena.sparql.core.*; 
import com.hp.hpl.jena.xmloutput.impl.*; 
import org.apache.jena.iri.impl.*; 
import com.hp.hpl.jena.tdb.nodetable.*; 
import com.hp.hpl.jena.sparql.engine.ref.*; 
import com.hp.hpl.jena.graph.*; 
import arq.*; 
import com.hp.hpl.jena.assembler.assemblers.*; 
import com.hp.hpl.jena.sparql.resultset.*; 
import com.hp.hpl.jena.sparql.core.assembler.*; 
import com.hp.hpl.jena.tdb.transaction.*; 
import org.apache.http.concurrent.*; 
import org.apache.xerces.xni.grammars.*; 
import com.hp.hpl.jena.ontology.*; 
import jena.*; 
import virtuoso.sql.*; 
import com.hp.hpl.jena.n3.turtle.parser.*; 
import com.hp.hpl.jena.tdb.base.recordbuffer.*; 
import org.w3c.dom.*; 
import org.apache.xerces.impl.validation.*; 
import com.hp.hpl.jena.sparql.syntax.*; 
import org.apache.jena.atlas.json.io.parser.*; 
import org.apache.xerces.stax.*; 
import org.apache.jena.atlas.json.io.parserjavacc.javacc.*; 
import org.apache.http.conn.scheme.*; 
import javax.xml.stream.events.*; 
import org.apache.xerces.util.*; 
import com.hp.hpl.jena.graph.impl.*; 
import org.apache.xerces.impl.xs.util.*; 
import org.apache.log4j.jdbc.*; 
import com.hp.hpl.jena.sparql.lang.sparql_11.*; 
import com.hp.hpl.jena.sparql.lang.sparql_10.*; 
import org.apache.log4j.xml.*; 
import com.hp.hpl.jena.sparql.expr.*; 
import javax.xml.transform.sax.*; 
import org.apache.xerces.parsers.*; 
import com.hp.hpl.jena.tdb.lib.*; 
import org.apache.jena.riot.stream.*; 
import com.hp.hpl.jena.ontology.impl.*; 
import javax.xml.namespace.*; 
import org.apache.http.*; 
import com.hp.hpl.jena.sparql.lang.*; 
import tdb.tools.*; 
import com.hp.hpl.jena.tdb.base.buffer.*; 
import org.apache.http.client.protocol.*; 
import org.apache.xerces.xs.datatypes.*; 
import org.apache.jena.atlas.event.*; 
import com.hp.hpl.jena.tdb.store.*; 
import org.apache.jena.atlas.logging.*; 
import com.hp.hpl.jena.enhanced.*; 
import org.apache.http.impl.client.*; 
import com.hp.hpl.jena.tdb.index.*; 
import com.hp.hpl.jena.sparql.core.describe.*; 
import com.hp.hpl.jena.sparql.serializer.*; 
import org.slf4j.helpers.*; 
import com.hp.hpl.jena.tdb.base.objectfile.*; 
import org.apache.jena.riot.web.*; 
import com.hp.hpl.jena.tdb.assembler.*; 
import org.apache.jena.atlas.json.io.parserjavacc.*; 
import com.hp.hpl.jena.sparql.pfunction.library.*; 
import org.apache.xml.serialize.*; 
import org.apache.xerces.impl.dtd.*; 
import virtuoso.jdbc3.*; 
import com.hp.hpl.jena.sparql.algebra.*; 
import org.apache.http.client.*; 
import org.apache.http.impl.io.*; 
import org.apache.log4j.or.jms.*; 
import org.apache.http.conn.params.*; 
import org.apache.xerces.xni.*; 
import org.w3c.dom.ls.*; 
import org.apache.http.impl.conn.tsccm.*; 
import org.apache.commons.codec.digest.*; 
import org.apache.commons.codec.net.*; 
import org.apache.xerces.dom.*; 
import org.apache.log4j.spi.*; 
import org.apache.jena.riot.other.*; 
import org.w3c.dom.stylesheets.*; 
import arq.cmd.*; 
import com.hp.hpl.jena.graph.compose.*; 
import org.apache.commons.codec.language.*; 
import javax.xml.*; 
import com.hp.hpl.jena.tdb.graph.*; 
import org.apache.log4j.lf5.viewer.*; 
import org.apache.xerces.xs.*; 
import org.apache.http.entity.*; 
import org.w3c.dom.traversal.*; 
import peasy.*; 
import com.hp.hpl.jena.sparql.engine.http.*; 
import com.hp.hpl.jena.reasoner.rulesys.*; 
import org.apache.jena.atlas.lib.*; 
import org.apache.jena.riot.writer.*; 
import com.hp.hpl.jena.tdb.store.bulkloader.*; 
import javax.xml.transform.stream.*; 
import javax.xml.xpath.*; 

import java.util.HashMap; 
import java.util.ArrayList; 
import java.io.File; 
import java.io.BufferedReader; 
import java.io.PrintWriter; 
import java.io.InputStream; 
import java.io.OutputStream; 
import java.io.IOException; 

public class nodes extends PApplet {

/*
  Coloring triples colors edges.
  Coloring resources colors nodes.
  
  Only nodes may be moved.
  
  Only triples may be hidden/shown.
*/











PeasyCam cam;
int initZoom;
int backG;

ControlP5 cp5;
UnProjector proj;

Graph graph;

TestFrame tf;
ArrayList<String> dispHolder;
String defaultDisp;

// Virtuoso test environment data
String URL = "jdbc:virtuoso://129.128.212.41:1111";
String USER = "dba";
String PASS = "marek";
String GRAPH = "Arts";
String PICASSO_URI = "http://dbpedia.org/resource/Pablo_Picasso";
String EDVARD_URI = "http://dbpedia.org/resource/Edvard_Munch";
String CLIFFORD_URI = "http://dbpedia.org/resource/Clifton_Pugh";

public void setup() {
  int w = 800;
  int h = 600;
  size(w, h , P3D);
  
  initZoom = 1500;
  dispHolder = new ArrayList<String>();
  defaultDisp = "Hover over graph elements for information:\n\n";
  dispHolder.add(defaultDisp);
  
  cam = new PeasyCam(this, 0, 0, 0, initZoom);
  cam.setMinimumDistance(10);
  cam.setMaximumDistance(10000);
  
  
  cp5 = new ControlP5(this);
  proj = new UnProjector();
  
  graph = new Graph(proj, cp5);
  
  virtAddNeighbors(PICASSO_URI);
  virtAddNeighbors(EDVARD_URI);
  virtAddNeighbors(CLIFFORD_URI);
  
  tf = addTestFrame("Test Controls", cam);
  
  CallbackListener hoverer = new CallbackListener() {
    public void controlEvent(CallbackEvent event) {
      if (event.getAction() == ControlP5.ACTION_ENTER) {
        if (event.getController() instanceof Node) {
          Node n = (Node) event.getController();
          dispHolder.add(getNodeString(n));
        } else {
          Edge e = (Edge) event.getController();
          dispHolder.add(getEdgeString(e));
        }
      } else if (event.getAction() == ControlP5.ACTION_LEAVE) {
        if (event.getController() instanceof Node) {
          Node n = (Node) event.getController();
          dispHolder.remove(getNodeString(n));
        } else {
          Edge e = (Edge) event.getController();
          dispHolder.remove(getEdgeString(e));
        }
      }
    }
  };
  cp5.addCallback(hoverer);

}

public void draw() {
  if (tf.layout.getItem(0).getState()) {
    graph.layout();
  }
  
  proj.captureViewMatrix((PGraphics3D) this.g);
  
  proj.calculatePickPoints(mouseX, mouseY);
  pointLight(255, 255, 255, proj.ptStartPos.x, proj.ptStartPos.y, proj.ptStartPos.z);
  
  background(0xFFE07924);
}

public String getStarQuery(String URI) {
  return "CONSTRUCT { <" + URI + "> ?p ?o } WHERE { GRAPH <" + GRAPH + "> { <" + URI + "> ?p ?o } }";
}

public void virtAddNeighbors(String uri) {
  VirtGraph g = new VirtGraph(GRAPH, URL, USER, PASS);
  Query sparql = QueryFactory.create(getStarQuery(uri));
  VirtuosoQueryExecution vqe = VirtuosoQueryExecutionFactory.create(sparql, g);
  Model toAdd = ModelFactory.createDefaultModel();
  vqe.execConstruct(toAdd);
  
  graph.addTriples(toAdd);
  
  g.close();
  vqe.close();
  toAdd.close();
}

/*
*  TEST CONTROL WINDOW
*/

public TestFrame addTestFrame(String theName, PeasyCam c) {
  Frame f = new Frame(theName);
  TestFrame p = new TestFrame(this, c);
  f.add(p);
  p.init();
  f.setTitle(theName);
  f.setSize(p.w, p.h);
  f.setLocation(0, 0);
  f.setResizable(true);
  f.setVisible(true);
  return p;
}

public class TestFrame extends PApplet {
  
  ControlP5 _cp5;
  Object _parent;
  
  PeasyCam viewCam;
  
  int w, h;
  
  public Slider zoom;
  public RadioButton layout;
  public Textlabel info;
  
  public String def;
  
  public void setup() {
    size(w, h);
    frameRate(25);
    _cp5 = new ControlP5(this);
    
    zoom = _cp5.addSlider("Zoom")
               .setPosition(10, 10)
               .setSize(200, 20)
               .setRange(100, 3000)
               .setValue(initZoom);
               
    zoom.addCallback(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        if (event.getAction() == ControlP5.ACTION_BROADCAST) {
          viewCam.setDistance(zoom.getValue());
        }
      }
    }
    );
               
    layout = _cp5.addRadioButton("layout")
                 .setPosition(10, 50)
                 .setSize(40,20)
                 .setColorForeground(color(120))
                 .setColorActive(color(255))
                 .setColorLabel(color(255))
                 .setItemsPerRow(1)
                 .setSpacingColumn(50)
                 .addItem("LAYOUT",0);
                 
    Toggle t = layout.getItem(0);
    t.captionLabel().setColorBackground(color(255,80));
    t.captionLabel().style().moveMargin(-7,0,0,-3);
    t.captionLabel().style().movePadding(7,0,0,3);
    t.captionLabel().style().backgroundWidth = 45;
    t.captionLabel().style().backgroundHeight = 13;
    
               
    info = _cp5.addTextlabel("Info")
               .setText(defaultDisp)
               .setPosition(10, 100)
               .setColorValue(0xffffff00)
               .setFont(createFont("Georgia",16));
  }
  
  public void draw() {
    String toDisp = "";
    for (String s : dispHolder) {
      toDisp += s;
    }
    info.setText(toDisp);
    background(0);
  }
  
  private TestFrame() {
    
  }
  
  public TestFrame(Object P, PeasyCam c) {
    _parent = P;
    viewCam = c;
    
    w = 600;
    h = 600;
  }
  
  public ControlP5 control() {
    return _cp5;
  }
}

public String getNodeString(Node n) {
  return "Node:\n  " + n.getName() + "\n\n";
}

public String getEdgeString(Edge e) {
  String toAdd = "Edge between:\n  "
                 + e.src.getName() + "\nand\n  " + e.dst.getName()
                 + "\nwith predicates\n  ";
  
  for (String p : e.predicates) {
    toAdd += p + "\n  ";
  }
  return toAdd + "\n\n";
}


class Edge extends Controller<Edge> {
  int defaultCol = 0xFF1A4969;
  int hoverCol = 0xFF5FEA6D;
  int clickCol = 0xFFEA5F84;
  
  int currentCol = defaultCol;
  
  float size;
  
  // edge shouldn't be long enough to touch its nodes. (cleaner looking)
  // NOTE: using this to directly scale theta in inside() causes a bit
  //       of scaling error, since theta is an angle, not a length
  float lengthScale;
  
  Node src;
  Node dst;
  
  ArrayList<String> predicates;
  
  UnProjector proj;
  
  Edge(ControlP5 cp5, String name, UnProjector unProj, Node s, Node d) {
    super(cp5, name);
    
    src = s;
    dst = d;
    
    predicates = new ArrayList<String>();

    proj = unProj;
    
    setPosition();
    
    lengthScale = 0.9f;
    
    setView(new ControllerView() {
        public void display(PApplet p, Object e) {
          Edge edge = (Edge) e;
          
          edge.setPosition();
          
          // get vector between the source and the destination nodes
          PVector between = edge.dst.getPosition().get();
          between.sub(edge.src.getPosition());
          
          
          p.pushMatrix();
          p.fill(currentCol);
          // Translate(x,y,0) called already, but nodes are in 3D
          p.translate(0,0,edge.getPosition().z);
          
          
          // Rotate towards the destination node to orient the edge
          PVector  target = between.get();
          target.normalize();
          
          PVector up = new PVector(0,0,1);
          
          PVector axis = target.cross(up);
          axis.normalize();
          
          float angle = PVector.angleBetween(target, up);
          
          p.rotate(-1*angle, axis.x, axis.y, axis.z);
          
          float len = between.mag() - edge.src.size - edge.dst.size;
          p.box(edge.size, edge.size, edge.lengthScale*len); 
          p.popMatrix();
        }
      }
    );
  }
  
  public boolean inside() {
    // NOTE:  steps 1** and 2** may be switched in dependency for speed.
    
    proj.calculatePickPoints(mouseX, mouseY);
    
    // vector mouse is from cursor inward orthogonally from the screen
    PVector mouse = proj.ptEndPos.get();
    mouse.sub(proj.ptStartPos);
    
    // get edge vector between the source and the destination nodes
    PVector between = dst.getPosition().get();
    between.sub(src.getPosition());
    
    //  find shortest distance between mouse and edge vectors (lines)
    //  1 **
    
    // get normalized vector orthogonal to both.
    // (p,q,r) of this vector defines the coefficients of all planes
    // orthogonal to both vectors: px + qy + rz = C
    PVector orthogonal = mouse.cross(between);
    orthogonal.normalize();
    
    // find constant C for plane containing mouse and edge lines.
    // because |orthogonal| == 1, C represents the displacement of
    // the plane along the orthogonal vector defining it
    float mouseC = orthogonal.x * proj.ptStartPos.x +
                    orthogonal.y * proj.ptStartPos.y +
                    orthogonal.z * proj.ptStartPos.z;
                    
    float edgeC = orthogonal.x * src.getPosition().x +
                    orthogonal.y * src.getPosition().y +
                    orthogonal.z * src.getPosition().z;
                    
    // hooray!
    float dist = abs(mouseC - edgeC);
    
    // test if shortest distance between edge and mouse lines is within
    // the size constraint of the edge
    if (dist < size) {
      
      //  determine whether or not the mouse vector is within the ongular
      //  sweep of the edge vector
      //  2 **
      
      // get angular displacement of edge
      PVector toSource = src.getPosition().get();
      toSource.sub(proj.ptStartPos);
      
      PVector toDest = dst.getPosition().get();
      toDest.sub(proj.ptStartPos);
      
      float theta = lengthScale * PVector.angleBetween(toSource, toDest);
      
      // get angles from mouse to source and from mouse to destination
      float phi1 = PVector.angleBetween(toSource, mouse);
      float phi2 = PVector.angleBetween(toDest, mouse);
      
      return phi1 < theta && phi2 < theta;
    } 
    
    return false;
  }
  
  public Edge setPosition() {
    PVector sPos = src.getPosition();
    PVector dPos = dst.getPosition();
    
    float dist = PVector.dist(sPos, dPos);
    
    // get the offset in midpoint between the nodes w.r.t their radii
    float scale = 0.5f * (1 + (src.size - dst.size) / dist);
    
    // get the (scaled) midpoint between the source and the destination
    PVector midpoint = PVector.lerp(sPos, dPos, scale);
    return setPosition(midpoint);
  }
  
  public Edge setSize(final int s) {
    size = s;
    return setSize(s, s);
  }
  
  public void onClick() {
    currentCol = clickCol;
  }
  
  public void onEnter() {
    currentCol = hoverCol;
  }
  
  public void onLeave() {
    currentCol = defaultCol;
  }
  
  public void mouseReleasedOutside() {
    currentCol = defaultCol;
  }
}

/*
Graph data structure whose nodes and edges are UI controllers in 3D.

The graph is an undirected graph without parallel edges, and it is 
meant to be a view abstraction over the directed multigraph RDF model
within the enclosed jena Model.

Node ids are the URIs or literal values that they represent.
Edge ids are the src and dst Node ids concatenated about "|".
  note: be careful of order when constructing edge ids.

Redundancy in representation:  an adjacency list keeps track of
edges, and there are also Edge objects which know a source and 
destination Node.
*/







class Graph {
  
  UnProjector proj;
  ControlP5 cp5;
  
  Model triples;
  
  int nodeCount;
  int edgeCount;
  
  // adjacent maps node ids (uris and literal values) to lists of node ids
  // NOTE: if things get slow for edge operations, try Set instead of ArrayList 
  HashMap<String, ArrayList<String>> adjacent;
  
  Graph(UnProjector p, ControlP5 c) {
    proj = p;
    cp5 = c;
    
    triples = ModelFactory.createDefaultModel();
    
    nodeCount = 0;
    edgeCount = 0;
    
    adjacent = new HashMap<String, ArrayList<String>>();
  }
  
  public void layout() {
    HashMap<String, PVector> deltas = new HashMap<String, PVector>();
    
    float coulomb = 10000;
    float hooke = .05f;
    
    float saturation = 50;
    
    for (String nodeID : adjacent.keySet()) {
      deltas.put(nodeID, new PVector(0,0,0));
    }
    for (String nodeID : adjacent.keySet()) {
      PVector delta = deltas.get(nodeID);
      Node n = (Node) cp5.getController(nodeID);
      PVector nodePos = n.getPosition();
      
      for (String nbrID : adjacent.get(nodeID)) {
        PVector diff = cp5.getController(nbrID).getPosition().get();
        diff.sub(nodePos);
        float dist = diff.mag();
        diff.normalize();
        diff.mult(hooke * sq(dist));
        delta.add(diff);
      }
      
      for (String otherID : adjacent.keySet()) {
        if (otherID != nodeID) {
          float degreeScale = PApplet.parseFloat(getDegree(otherID) * getDegree(nodeID));
          
          PVector diff = cp5.getController(otherID).getPosition().get();
          diff.sub(nodePos);
          
          float dist = diff.mag();
          
          diff.normalize();
          diff.mult(degreeScale * coulomb / dist);
          delta.sub(diff);
        }
      }
    }
    
    for (String nodeID : adjacent.keySet()) {
      //apply damping and set
      PVector delta = deltas.get(nodeID);
      float mag = delta.mag();
      delta.limit(log(mag)/log(2));
      
      PVector pos = cp5.getController(nodeID).getPosition();
      pos.add(delta);
      //print(deltas.get(nodeID));
    }
  }
  
  /*
  * adds triples to model, adding (transformed) Nodes and Edges as necessary
  */
  public void addTriples(Model toAdd) {
    StmtIterator it = toAdd.listStatements();
    if (it.hasNext()) {
      while (it.hasNext()) {
        Statement s = it.nextStatement();
        addTriple(s);
      }
    } else {
      println("Empty query result.");
    }
  }
  
  public Edge addTriple(Statement triple) {
    String sub = triple.getSubject().toString();
    String pred = triple.getPredicate().toString();
    String obj = triple.getObject().toString();
    
    Edge e;
    
    // add*** just returns the existing *** if a new *** need not be created.  (think sets)
    addNode(sub);
    addNode(obj);
    e = addEdge(sub, obj);
    e.predicates.add(pred);
    return e;
  }
  
  
  public ArrayList<String> getNbrs(String id) {
    return adjacent.get(id);
  }
  public ArrayList<String> getNbrs(Node n) {
    return getNbrs(n.getName());
  }
  
  // return node's degree for view graph, not for the relational graph
  public int getDegree(String id) {
    return getNbrs(id).size();
  }
  public int getDegree(Node n) {
    return getDegree(n.getName());
  }
  
  /*
  * to be called by addTriple and .
  * affects cp5, nodeCount, and adjacent iff the node is new.
  * a new entry in adjacent will map to an empty ArrayList since no edges may exist yet.
  *
  * returns the new node or the existing node.
  */
  private Node addNode(String id) {
    if (adjacent.containsKey(id)) {
      return (Node) cp5.getController(id);
    } else {
      int initBoundary = 500;
      Node n = new Node(cp5, id, proj)  
                    .setPosition(random(-initBoundary,initBoundary), 
                                 random(-initBoundary,initBoundary), 
                                 random(-initBoundary,initBoundary))
                    .setSize(10);
                    
      adjacent.put(id, new ArrayList<String>());
      
      nodeCount += 1;
      
      return n;
    }
  }
  
  /*
  * to be called by addTriple, both nodes must exist.
  * affects cp5, edgeCount, and adjacent iff the edge is new.
  * 
  * returns the new edge or the existing edge.
  */
  private Edge addEdge(String s, String d) {
    if (adjacent.get(s).contains(d)) {
      return getEdge(s, d);
    } else {
      Node src = (Node) cp5.getController(s);
      Node dst = (Node) cp5.getController(d);
      Edge e = new Edge(cp5, s + "|" + d, proj, src, dst).setSize(5);
      
      adjacent.get(s).add(d);
      adjacent.get(d).add(s);
      edgeCount += 1;
      
      return e;
    }
    
  }
  private Edge addEdge(Node s, Node d) {
    return addEdge(s.getName(), d.getName());
  }
  
  /*
  * returns true if successful, false otherwise.
  */ 
  private boolean removeNode(String id) {
    if (!adjacent.containsKey(id)) {
      println("Cannot remove nonexistent node\n" + id);
      return false;
    } else if (!adjacent.get(id).isEmpty()) {
      println("Cannot remove still-connected node\n" + id);
      return false;
    } else {
      //node exists and has no neighbors
      cp5.getController(id).remove();
      
      adjacent.remove(id);
      nodeCount -= 1;
      
      return true;
    }
  }
  private boolean removeNode(Node n) {
    return removeNode(n.getName());
  }
  
  /*
  * returns true if successful, false otherwise.
  */ 
  private boolean removeEdge(String s, String d) {
    if ( ! (adjacent.containsKey(s) && adjacent.containsKey(d))) {
      println("Cannot remove edge, one of src or dst doesn't exist:\n"+s+"\n"+d);
      return false;
    } else if (!adjacent.get(s).contains(d)) {
      println("Cannot remove nonexistent edge between:\n"+s+"\n"+d);
      return false;
    } else {
      Edge e = (Edge) cp5.getController(s + "|" + d);
      if (e == null) e = (Edge) cp5.getController(d + "|" + s);
      
      e.remove();
      
      adjacent.get(s).remove(d);
      adjacent.get(d).remove(s);
      
      edgeCount -= 1;
      return true;
    }
  }
  private boolean removeEdge(Node s, Node d) {
    return removeEdge(s.getName(), d.getName());
  }
  private boolean removeEdge(Edge e) {
    return removeEdge(e.src, e.dst);
  }
  
  private Edge getEdge(String s, String d) {
    Edge e = (Edge) cp5.getController(s + "|" + d);
      
    if (e == null) e = (Edge) cp5.getController(d + "|" + s);
    
    if (e == null) println("Edge connecting\n"+s+"\nand\n"+d+"\nnot found.");
    return e;
  }
  
}
class Node extends Controller<Node> {
  
  int defaultCol = 0xFF1A4969;
  int hoverCol = 0xFF5FEA6D;
  int clickCol = 0xFFEA5F84;
  
  int currentCol = defaultCol;
  
  float size;
  
  UnProjector proj;
  
    
  // name of controller is the URI or literal value
  // UnProjector is for 3D extension of inside()
  Node(ControlP5 cp5, String name, UnProjector unProj) {
    super(cp5, name);

    proj = unProj;
    
    setView(new ControllerView() {
        public void display(PApplet p, Object n) {
          Node node = (Node) n;
          
          
          p.pushMatrix();
          p.fill(currentCol);
          // Translate(x,y,0) called already, but nodes are in 3D
          p.translate(0,0,node.getPosition().z);
          p.sphere(node.size); 
          p.popMatrix();
        }
      }
    );
  }

  public boolean inside() {

    proj.calculatePickPoints(mouseX, mouseY);
    
    // vector mouse is from cursor inward orthogonally from the screen
    PVector mouse = proj.ptEndPos.get();
    mouse.sub(proj.ptStartPos);
    
    // vector obj is from the cursor to the position of the node
    PVector obj = getPosition().get();;
    obj.sub(proj.ptStartPos);

    // theta is the angle between the mouse vector and the object vector
    float theta = PVector.angleBetween(mouse, obj);

    // phi is the angular displacement of the radius of the node
    float phi = atan(size/obj.mag());

    // the cursor is inside the node if theta is less than phi
    return theta < phi;
  }
  
  public Node setPosition(final float x, final float y, final float z) {
    return setPosition(new PVector(x, y, z));
  }
  
  public Node setSize(final int s) {
    size = s;
    return setSize(s, s);
  }
  
  public void onClick() {
    currentCol = clickCol;
  }
  
  public void onEnter() {
    currentCol = hoverCol;
  }
  
  public void onLeave() {
    currentCol = defaultCol;
  }
  
  public void mouseReleasedOutside() {
    currentCol = defaultCol;
  }

}
public class UnProjector
{
  
  // True if near and far points calculated.
  public boolean isValid() { return m_bValid; }
  private boolean m_bValid = false;
  
  // Maintain own projection matrix.
  public PMatrix3D getMatrix() { return m_pMatrix; }
  private PMatrix3D m_pMatrix = new PMatrix3D();
 
   // Maintain own viewport data.
  public int[] getViewport() { return m_aiViewport; }
  private int[] m_aiViewport = new int[4];

  // Store the near and far ray positions.
  public PVector ptStartPos = new PVector();
  public PVector ptEndPos = new PVector();

  // -------------------------

  public void captureViewMatrix(PGraphics3D g3d)
  { // Call this to capture the selection matrix after 
    // you have called perspective() or ortho() and applied your
    // pan, zoom and camera angles - but before you start drawing
    // or playing with the matrices any further.
    
    if (g3d == null)
    { // Use main canvas if it is P3D, OPENGL or A3D.
      g3d = (PGraphics3D)g;
    }

    if (g3d != null)
    { // Check for a valid 3D canvas.

      // Capture current projection matrix.
      m_pMatrix.set(g3d.projection);
  
      // Multiply by current modelview matrix.
      m_pMatrix.apply(g3d.modelview);
  
      // Invert the resultant matrix.
      m_pMatrix.invert();
        
      // Store the viewport.
      m_aiViewport[0] = 0;
      m_aiViewport[1] = 0;
      m_aiViewport[2] = g3d.width;
      m_aiViewport[3] = g3d.height;
      
    }
  
  }

  // -------------------------

  public boolean gluUnProject(float winx, float winy, float winz, PVector result)
  {

    float[] in = new float[4];
    float[] out = new float[4];

    // Transform to normalized screen coordinates (-1 to 1).
    in[0] = ((winx - (float)m_aiViewport[0]) / (float)m_aiViewport[2]) * 2.0f - 1.0f;
    in[1] = ((winy - (float)m_aiViewport[1]) / (float)m_aiViewport[3]) * 2.0f - 1.0f;
    in[2] = constrain(winz, 0f, 1f) * 2.0f - 1.0f;
    in[3] = 1.0f;

    // Calculate homogeneous coordinates.
    out[0] = m_pMatrix.m00 * in[0]
           + m_pMatrix.m01 * in[1]
           + m_pMatrix.m02 * in[2]
           + m_pMatrix.m03 * in[3];
    out[1] = m_pMatrix.m10 * in[0]
           + m_pMatrix.m11 * in[1]
           + m_pMatrix.m12 * in[2]
           + m_pMatrix.m13 * in[3];
    out[2] = m_pMatrix.m20 * in[0]
           + m_pMatrix.m21 * in[1]
           + m_pMatrix.m22 * in[2]
           + m_pMatrix.m23 * in[3];
    out[3] = m_pMatrix.m30 * in[0]
           + m_pMatrix.m31 * in[1]
           + m_pMatrix.m32 * in[2]
           + m_pMatrix.m33 * in[3];

    if (out[3] == 0.0f)
    { // Check for an invalid result.
      result.x = 0.0f;
      result.y = 0.0f;
      result.z = 0.0f;
      return false;
    }

    // Scale to world coordinates.
    out[3] = 1.0f / out[3];
    result.x = out[0] * out[3];
    result.y = out[1] * out[3];
    result.z = out[2] * out[3];
    return true;

  }
  
  public boolean calculatePickPoints(int x, int y)
  { // Calculate positions on the near and far 3D frustum planes.
    m_bValid = true; // Have to do both in order to reset PVector on error.
    if (!gluUnProject((float)x, height - (float)y, 0.0f, ptStartPos)) m_bValid = false;
    if (!gluUnProject((float)x, height - (float)y, 1.0f, ptEndPos)) m_bValid = false;
    return m_bValid;
  }
  
}

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "nodes" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
